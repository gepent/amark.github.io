

### 索引的作用：索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

### 索引的常见模型：

- 哈希

##### 举例说明：现在要维护一个身份证号与姓名关系的表，我们可以将身份证号用哈希函数换算成一个确定的位置，然后把name存到这个位置，但是这样带来一个问题就是，身份证号存储必然不是连续的，这样导致范围查询没有优势，因此对于哈希这种模型适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。

- 有序列表

##### 有序数组索引只适用于静态存储引擎，如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

- 平衡二叉树

##### 平衡二叉树，查询与修改的时间复杂度都是 O(log(N))，但是，实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上

事实上，不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，其中有一种 N 叉树成为上帝的宠儿，人们把它叫做：B+树


### InnoDB 的索引模型


在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的

在B+树中根据叶子节点的内容索引类型可以分为主键索引和非主键索引

基于主键索引和普通索引的查询有什么区别？

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。


关于索引优化的三个原则：

### 覆盖索引 (避免回表)

### 最左前缀原则 

比如已经建立了联合索引(a, b)，查询条件 a, b, a and b, a and c，哪些能使用上索引

a，a and b, a and c 可以用上索引，b 用不上，其中 a and b 会完全使用联合索引

### 索引下推

可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

比如：
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
