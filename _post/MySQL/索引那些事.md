

### 索引的作用：索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

### 索引的常见模型：

- 哈希

##### 举例说明：现在要维护一个身份证号与姓名关系的表，我们可以将身份证号用哈希函数换算成一个确定的位置，然后把name存到这个位置，但是这样带来一个问题就是，身份证号存储必然不是连续的，这样导致范围查询没有优势，因此对于哈希这种模型适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。

- 有序列表

##### 有序数组索引只适用于静态存储引擎，如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

- 平衡二叉树

##### 平衡二叉树，查询与修改的时间复杂度都是 O(log(N))，但是，实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上

事实上，不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，其中有一种 N 叉树成为上帝的宠儿，人们把它叫做：B+树


### InnoDB 的索引模型


在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的

在B+树中根据叶子节点的内容索引类型可以分为主键索引和非主键索引

基于主键索引和普通索引的查询有什么区别？

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。


### 关于索引优化的三个技巧：

##### 覆盖索引 (避免回表)

如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据

##### 最左前缀原则 

联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

比如已经建立了联合索引(a, b)，查询条件 a, b, a and b, a and c，哪些能使用上索引

a，a and b, a and c 可以用上索引，b 用不上，其中 a and b 会完全使用联合索引

##### 索引下推

可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

比如：

like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度


### 什么情况下创建索引，什么时候不需要索引？

- 在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的
- 当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引

### 索引的种类有哪些？

普通索引、唯一索引、主键索引和全文索引，其实前三种索引（普通索引、唯一索引和主键索引）都是一类索引，只不过对数据的约束性逐渐提升

根据逻辑功能区分：普通索引、唯一索引、主键索引和全文索引

根据物理实现区分：聚簇索引、非聚簇索引

- 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

根据字段个数区分：单一索引、联合索引
